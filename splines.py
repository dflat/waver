from pyrr import Matrix44, Vector3
import numpy as np

Bernstein = Matrix44([[1,-3,3,-1],[0,3,-6,3],[0,0,3,-3],[0,0,0,1]])

class Spline:
    Bernstein = Bernstein
    #Tangent = Matrix44([[1,-3,3,-1],[0,3,-6,3],[0,0,3,-3],[0,0,0,1]])

    def __init__(self, control_points):
        self.controls = control_points

    @property
    def controls(self):
        return self._controls

    @controls.setter
    def controls(self, points):
        self._controls = np.array(points).T
        self.GB = self._controls @ Spline.Bernstein

    def eval_one(self, t):
        return self.GB @ (1, t, t*t, t**3)

    def eval_vec(self, ts):
        """
        ::ts:: is a discrete time signal from 0 to 1.

        Returns an N by 3 (N = number of samples) matrix of points
        sampled from the underlying curve at times ts.
        """
        v = np.vander(ts, 4, increasing=True)
        return v @ self.GB.T 

    def sample(self, n):
        ts = np.linspace(0,1,n)
        return self.eval_vec(ts)

class SplinePatch:
    def __init__(self, control_points):
        """
        Mesh of 16 control points. Format should be a (3,4,4) numpy array,
        representing one 4x4 array for each component x,y, and z (i.e. a tensor).

        Control points can be generated by e.g., the wave_mesh function.
        """
        self.controls = control_points

    @property
    def controls(self):
        return self._controls

    @controls.setter
    def controls(self, point_tensor):
        B = Bernstein
        self._controls = point_tensor
        self.GB = B.T @ self._controls @ B # GB tensor

    def eval_one(self, u, v):
        """
        u and v are normalized coordinates in (0, 1)
        mapping onto the full scaled patch (i.e. u=1 => x=size)
        """
        U = np.array((1, u, u*u, u**3))
        V = np.array((1, v, v*v, v**3))
        #return U, self.GB, V
        # todo: why did U and V flipped here work
        return Vector3(np.array( (V.T @ self.GB @ U) )) 

    def get_normal(self, u, v):
        U = np.array((1, u, u*u, u**3))
        V = np.array((1, v, v*v, v**3))
        dU = np.array((0, 1, 2*u, 3*u*u))
        dV = np.array((0, 1, 2*v, 3*v*v))
        Tu = Vector3(np.array( (V.T @ self.GB @ dU) ))  
        Tv = Vector3(np.array( (dV.T @ self.GB @ U) ))  
        normal = np.cross(Tv.normalized, Tu.normalized)
        return Vector3(normal).normalized

    def eval_vec(self, u_samples, v_samples=None):
        if v_samples is None:
            v_samples = u_samples.copy() # maybe unnecessary
        U = np.vander(u_samples, 4, increasing=True)
        V = np.vander(v_samples, 4, increasing=True)
        return (U @ self.GB @ V.T).T

def wave_mesh(start=0, end=3, n=4, A=1):
    """ Make a square grid evaluated on a wave function,
        over interval (start, end) in x and y.
        return evalated points on n*n sample points,
        where n is the number of sampled points per axis.
    """
    I = (start, end)
    size = end-start
    X, Y = grid(I, I, n, n)
    B = np.ones_like(X)
    Z = wave2D(X,Y, xfreq=1/size, yfreq=1/size, A=A)
    #return np.array([Y, Z, X]) # TODO FIX THIS was X,Z,Y, but axis were reversed??
    return np.array([X, Z, Y]) # TODO FIX THIS was X,Z,Y, but axis were reversed??

def wave2D(X, Y, xfreq=1/3, yfreq=1/3, A=0.5):
    wx = 2*np.pi*xfreq
    wy = 2*np.pi*yfreq
    p = np.sin(wx*X)*np.cos(wy*Y)
    return A*p

def grid(x_range, y_range, nx, ny):
    x = np.linspace(x_range[0], x_range[1], nx)
    y = np.linspace(y_range[0], y_range[1], ny)
    return np.meshgrid(x, y)


def test(n=11):
    wm = wave_mesh()
    sp = SplinePatch(wm)
    ts = np.linspace(0,1,n)
    return sp
    return sp.eval_vec(ts)






















